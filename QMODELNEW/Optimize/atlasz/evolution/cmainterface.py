"""These functions are used to produce compatibility with the cma-es:
https://www.lri.fr/~hansen/cmaesintro.html

The main compatibility issue is the parameter range transformation. Here we
use the [0,1] range for all params internally but return pvalues in the
original range for compatibility with evolution.py
"""

#external imports
from __future__ import print_function
import cma
import numpy

#internal imports
import evolution
import selection


def init_cma(eparams, lastpvalues=None, fitnesses=None):
    """Initialize a cma object.

    :param eparams:      the evolutionparams python module name
    :param lastpvalues:  dict of evolvable pvalues for all phenotypes in the last generation.
    :param fitnesses:    dict of multi-objective fitnesses for all phenotypes in the last generation.
    """
    # set params
    params = evolution.get_params_to_evolve(eparams)
    n = len(params)

    opts = {
        'bounds': [[0]*n, [1]*n],
        'popsize': eparams.phenotypes,
        'maxiter': eparams.generations, # 100 + 50 * (N+3)**2
        'tolx': 10e-30, # TODO: set it to convenient value
    }
    std = 0.5/3. # TODO: how to set individual std? Is that possible at all?

    # initialization with no fitness data
    if fitnesses is None:
        # initialization with no pvalues
        if lastpvalues is None or "mean" not in lastpvalues:
            return cma.CMAEvolutionStrategy([0.5]*n, std, opts)
        # initialization with 'mean' pvalues
        else:
            # convert mean solution to [0,1]
            s = [(lastpvalues["mean"][i] - params[i].minv)/(params[i].maxv - params[i].minv) \
                    if params[i].maxv != params[i].minv else 0.5 for i in xrange(n)]
            return cma.CMAEvolutionStrategy(s, std, opts)
    # initialization with previously calculated data
    else:
        print ("  Warning: initialization with previously partially executed evolution is not optimized yet!")
        print ("           std should be calculated from previous data, because now a whole new evolution is started...")
        sfitnesses = evolution.get_single_fitnesses(fitnesses)
        best = lastpvalues[selection.elite(sfitnesses, 1)[0]]
        # convert best solution to [0,1]
        s = [(lastpvalues[best][i] - params[i].minv)/(params[i].maxv - params[i].minv) for i in xrange(n)]
        return cma.CMAEvolutionStrategy(s, std, opts)


def update_cma(cmaes, eparams):
    """Update a cmaes object with parameters in eparams."""
    # update generations as a termination condition
    if cmaes.opts.get('maxiter') != eparams.generations:
        print ("  Number of generations has been changed from %d to %d" % ( cmaes.opts.get('maxiter'), eparams.generations))
        cmaes.opts.set({'maxiter': eparams.generations})
    # TODO: add anything else that might be needed


def generate_population(cmaes, eparams):
    """Generate next population.

    :param cmaes:        the cma evolution strategy object
    :param eparams:      the evolutionparams python module name

    """
    params = evolution.get_params_to_evolve(eparams)
    solutions = cmaes.ask()
    pvalues = [[params[i].minv + s[i]*(params[i].maxv-params[i].minv) for i in xrange(len(s))] for s in solutions]
    return (solutions, pvalues)


def store_fitnesses(cmaes, fitnesses, solutions):
    """Forward the fitnesses to the cma object.

    :param cmaes:        the cma evolution strategy object
    :param fitnesses:    multi-objective fitness values of the last generation
    :param solutions:    the solutions generated by the previous cmaes.ask()

    """
    # note that it is a minimizer and we are a maximizer so -1 is needed
    sfitnesses = evolution.get_single_fitnesses(fitnesses)
    cmaes.tell(solutions, [-sfitnesses[i] for i in xrange(len(solutions))])


def is_termination(cmaes, eparams, fitnesses, g):
    """Termination function for the cma-es, inheriting the termination
    function of the standard evolution algo.

    :param cmaes:         the cma evolution strategy object
    :param eparams:       the evolutionparams python module name
    :param fitnesses:     multi-objective fitness values of the last generation
    :param g:             the next generation number

    :return:              True if termination is needed

    """
    return evolution.is_termination(eparams, fitnesses, g) or cmaes.stop()


def get_mean_solution(cmaes, eparams):
    """Return the mean solution of a cmaes object,
    with parameter values transformed back in original param ranges.

    :param cmaes:        the cma evolution strategy object
    :param eparams:      the evolutionparams python module name

    :return:             (mean solution, effective std)

    """
    params = evolution.get_params_to_evolve(eparams)
    mean_solution = cmaes.gp.pheno(cmaes.mean, copy=True, into_bounds=cmaes.boundary_handler.repair)
    if int(cma.__version__[0]) < 2:
        effective_std = cmaes.result()[6]
    else:
        effective_std = cmaes.result[6]
    pmean = [params[i].minv + mean_solution[i]*(params[i].maxv-params[i].minv) for i in xrange(len(mean_solution))]
    pstd = [effective_std[i]*(params[i].maxv-params[i].minv) for i in xrange(len(effective_std))]
    return (pmean, pstd)


def get_favorite_solution(cmaes, eparams):
    """Return the favorite solution (from cma.result) of a cmaes object,
    with parameter values transformed back in original param ranges.

    :param cmaes:        the cma evolution strategy object
    :param eparams:      the evolutionparams python module name

    :return:             (favorite solution, effective std)

    """
    params = evolution.get_params_to_evolve(eparams)
    if int(cma.__version__[0]) < 2:
        favorite_solution, effective_std = cmaes.result()[5:7]
    else:
        favorite_solution, effective_std = cmaes.result[5:7]
    pfavorite = [params[i].minv + favorite_solution[i]*(params[i].maxv-params[i].minv) for i in xrange(len(favorite_solution))]
    pstd = [effective_std[i]*(params[i].maxv-params[i].minv) for i in xrange(len(effective_std))]
    return (pfavorite, pstd)


def get_best_solution(cmaes, eparams):
    """Return the best solution (from cma.result) of a cmaes object,
    with parameter values transformed back in original param ranges.

    :param cmaes:        the cma evolution strategy object
    :param eparams:      the evolutionparams python module name

    :return:             (best solution, fitness, evalnum)

    """
    params = evolution.get_params_to_evolve(eparams)
    if int(cma.__version__[0]) < 2:
        best_solution, fitness_of_best, evalnum_of_best = cmaes.result()[0:3]
    else:
        best_solution, fitness_of_best, evalnum_of_best = cmaes.result[0:3]
    fitness_of_best = -fitness_of_best # we use positive fitness, cma uses negative
    pbest = [params[i].minv + best_solution[i]*(params[i].maxv-params[i].minv) for i in xrange(len(best_solution))]
    return (pbest, fitness_of_best, evalnum_of_best)
